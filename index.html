<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>プレゼンテーションに関するチェックリスト</title>
    <style>
    /* style.css */

/* 既存のCSSスタイル */

body {
    font-family: Arial, sans-serif;
    padding: 20px;
    background-color: #f9f9f9;
}

.tree-container {
    max-width: 1000px;
    margin: auto;
    background-color: #fff;
    padding: 20px 40px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
}

.tree {
    list-style-type: none;
    padding-left: 20px;
    position: relative;
}

.tree::before {
    content: '';
    position: absolute;
    top: 0;
    left: 10px;
    border-left: 1px solid #ccc;
    bottom: 0;
}

.tree li {
    margin: 0;
    padding: 10px 0 0 20px;
    position: relative;
}

.tree li::before {
    content: '';
    position: absolute;
    top: 15px;
    left: -10px;
    width: 10px;
    height: 0;
    border-top: 1px solid #ccc;
}

.tree-item {
    display: flex;
    align-items: center;
    position: relative;
}

.toggle-button {
    cursor: pointer;
    display: inline-block;
    width: 20px;
    text-align: center;
    margin-right: 5px;
    transition: transform 0.3s;
    user-select: none;
    font-size: 14px;
    background: none;
    border: none;
    padding: 0;
}

.toggle-button.expanded {
    transform: rotate(90deg);
}

.item-label {
    margin-right: 10px;
    flex-grow: 1;
    cursor: default;
}

.progress-indicator {
    display: flex;
    gap: 5px;
}

.step {
    width: 24px;
    height: 24px;
    border: 2px solid #999;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    background-color: #f0f0f0;
    transition: background-color 0.3s, color 0.3s, transform 0.2s;
    font-size: 12px;
}

.step:hover {
    transform: scale(1.2);
}

.step.active {
    background-color: #4caf50;
    color: white;
    border-color: #4caf50;
}

.step:focus {
    outline: none;
    box-shadow: 0 0 0 2px #4caf50;
}

.hidden {
    display: none;
}

h2 {
    text-align: center;
    margin-bottom: 20px;
    color: #333;
}

/* 親項目の進捗バー */
.progress-bar-container {
    width: 200px;
    background-color: #e0e0e0;
    border-radius: 10px;
    overflow: hidden;
    height: 20px;
    margin-left: 10px;
    position: relative;
}

.progress-bar {
    height: 100%;
    background-color: #4caf50;
    width: 0%;
    transition: width 0.5s ease-in-out, background-color 0.3s;
}

.progress-bar-container:hover .progress-bar {
    background-color: #45a049;
}

.progress-text {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    font-size: 12px;
    line-height: 20px;
    color: #fff;
    pointer-events: none;
}

.snapshot-list {
    max-height: 200px;
    overflow-y: auto;
    margin-top: 10px;
}

.snapshot-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px 0;
    border-bottom: 1px solid #ccc;
}

.snapshot-item:last-child {
    border-bottom: none;
}

.snapshot-item button {
    padding: 2px 5px;
    font-size: 12px;
}

/* Collapsible sections */
.collapsible-section {
    /* flex: 1; 既に横並びにするコンテナ内で均等配置されるため削除 */
}
.collapsible-header {
    cursor: pointer;
    font-weight: bold;
    background: #eaeaea;
    padding: 8px;
    border-radius: 4px;
    margin-top: 10px; /* お好みで調整 */
}
.collapsible-content {
    margin-top: 8px;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    display: none;
    background: #fafafa;
}
.collapsible-content.show {
    display: block;
}

/* 2つの折りたたみセクションを横一列に並べる用のコンテナ */
.collapsible-sections-row {
    display: flex;
    align-items: flex-start;
    gap: 20px;
    margin-top: 10px;
    margin-bottom: 10px;
}

/* Responsive adjustments */
@media (max-width: 600px) {
    .progress-bar-container {
        width: 100%;
    }
    .collapsible-sections-row {
        display: block; /* スマホなどでは縦に並べる */
    }
}

/* Comparison checkboxes */
.comparison-list {
    margin-top: 10px;
    max-height: 150px;
    overflow-y: auto;
}
.comparison-item {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
}

/* フィードバックセクションのスタイリング */
.feedback-section {
    margin-top: 20px;
    padding: 15px;
    border: 1px solid #ccc;
    border-radius: 5px;
    background-color: #ffffff;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
}
.feedback-section h3 {
    margin-bottom: 10px;
    color: #333;
}
.feedback-section textarea {
    width: 100%;
    height: 150px;
    font-family: monospace;
    font-size: 14px;
    padding: 10px;
    box-sizing: border-box;
    resize: vertical;
    margin-bottom: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.feedback-section button {
    padding: 8px 16px;
    font-size: 14px;
    cursor: pointer;
    background-color: #2196F3;
    color: white;
    border: none;
    border-radius: 4px;
}
.feedback-section button:hover {
    background-color: #0b7dda;
}
.feedback-section #feedbackContent {
    margin-top: 20px;
}
.feedback-section .error {
    color: red;
    font-weight: bold;
}
    </style>
    <!-- 必要なライブラリのロード -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel for in-browser JSX transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- html2pdf.js for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <!-- js-yaml for YAML export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-yaml/4.1.0/js-yaml.min.js"></script>
    <!-- marked.js for Markdown to HTML conversion -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <!-- ttttmp.js をロード -->
    <script src="https://script.googleusercontent.com/a/macros/g.hst.titech.ac.jp/echo?user_content_key=OQs8-43Ox2aHDL9K58ZS5CMez4-ZSb76znyZwySm7FB5ySrpntf3ZC-dy0wee-C7HMWOd4XjbZ5eq1ZxpkHhmyk7xjz2tWkjOJmA1Yb3SEsKFZqtv3DaNYcMrmhZHmUMi80zadyHLKAYbQ251-aFXyJ9s1c2e3FJseJeKI8Xa6e4u5ToZa5M5Ay6qfsfLOmMHeRA-SS-RukqZC8f9AwS_6suOJYZcSwtNubOdmxKu2zUd1WY3d2ZMfe7iTWCBsu9Xmf3ctEFbqULdlCGsdfoNQQXf5Vr5Jrtr1Pq8WJ6mDo&lib=MNpFM9nJW3p1_VI6EAmMUpHF0_eapoXVb"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/javascript">const encouragementPresets = {
    "原稿": {
      "わかりやすい英語で書かれているか": {
        5: [
          "わかりやすい英語で非常に優れた原稿が作成されています。",
          "英語表現が明確で、理解しやすい原稿となっています。",
          "素晴らしい英語の使用で、原稿が非常に分かりやすくなっています。"
        ],
        4: [
          "わかりやすい英語で良好な原稿が作成されています。",
          "英語の表現が明瞭で、原稿が理解しやすいです。",
          "良好な英語の使用で、原稿が分かりやすくまとめられています。"
        ],
        3: [
          "わかりやすい英語で原稿が作成されていますが、さらに改善の余地があります。",
          "英語表現は概ね良好ですが、もう少し明確にすると良いでしょう。",
          "英語の使用が適切ですが、さらなる明確化が望まれます。"
        ]
        // スコア2および1の場合は改善が必要なのでencouragementは不要
      },
      "分かりやすい構成で書かれているか": {
        5: [
          "構成が明確で、論理的な流れがしっかりとしています。",
          "論理的な構成で、情報が一貫して整理されています。",
          "非常に明確な構成で、聴衆に理解しやすい内容です。"
        ],
        4: [
          "構成が良好で、情報が整理されています。",
          "論理的な構成で、内容が一貫しています。",
          "良い構成で、情報が整理されて伝わりやすいです。"
        ],
        3: [
          "構成は理解できますが、さらなる整理が望まれます。",
          "論理的な流れはありますが、もう少し整理すると良いでしょう。",
          "構成は概ね良好ですが、もう少し明確化が必要です。"
        ]
        // スコア2および1の場合は改善が必要なのでencouragementは不要
      },
      "要点をまとめて書かれているか": {
        5: [
          "要点が明確にまとめられており、非常に効果的です。",
          "要点がしっかりとまとめられています。",
          "要点が簡潔にまとめられ、聴衆に伝わりやすいです。"
        ],
        4: [
          "要点がしっかりとまとめられています。",
          "要点が明確で、プレゼンテーションに一貫性があります。",
          "要点が適切に整理されており、理解しやすいです。"
        ],
        3: [
          "要点はまとめられていますが、さらに明確にすることができます。",
          "要点をもう少し具体的に整理すると良いでしょう。",
          "要点が概ねまとめられていますが、もう少し強調すると良いです。"
        ]
        // スコア2および1の場合は改善が必要なのでencouragementは不要
      },
      "客観的なデータに基づいて書かれているか": {
        5: [
          "客観的なデータに基づき、信頼性の高い原稿です。",
          "豊富な客観的データが使用されており、説得力があります。",
          "客観的なデータが適切に活用され、原稿の信頼性が高まっています。"
        ],
        4: [
          "客観的なデータが適切に使用されています。",
          "客観的なデータの引用が良好で、内容に信頼性があります。",
          "データが効果的に活用されており、原稿に説得力を加えています。"
        ],
        3: [
          "データは使用されていますが、より多くの客観的情報が望まれます。",
          "客観的なデータが一部使用されていますが、さらに追加すると良いでしょう。",
          "データの使用は適切ですが、追加の客観的情報があると更に良いです。"
        ]
        // スコア2および1の場合は改善が必要なのでencouragementは不要
      }
    },
    "話し方": {
      "抑揚をつける話しているか": {
        5: [
          "話し方に抑揚があり、聴衆を引き付けています。",
          "抑揚豊かな話し方で、聴衆の関心を維持しています。",
          "効果的な抑揚で、プレゼンテーションが生き生きとしています。"
        ],
        4: [
          "話し方に良い抑揚が見られます。",
          "抑揚が適切で、聴衆に伝わりやすいです。",
          "良好な抑揚で、話の流れがスムーズです。"
        ],
        3: [
          "話し方に抑揚があるものの、さらなる工夫が可能です。",
          "抑揚はありますが、もう少し感情を込めると良いでしょう。",
          "抑揚が適度にありますが、さらに強調すると効果的です。"
        ]
      },
      "はっきりと大きな声で話しているか": {
        5: [
          "声が非常に大きく、はっきりと聞き取れます。",
          "力強い声で、聴衆に明確に伝わっています。",
          "非常に明瞭な発声で、全体に響き渡っています。"
        ],
        4: [
          "声が大きく、はっきりと話しています。",
          "明瞭な声で、聴衆に伝わりやすいです。",
          "良好な声量で、内容が明確に伝わります。"
        ],
        3: [
          "声の大きさは良好ですが、もう少し明瞭に話すと良いでしょう。",
          "声は大きいですが、明瞭さをさらに高めることができます。",
          "適切な声量ですが、発音の明瞭さを向上させると良いでしょう。"
        ]
      },
      "聞き取りやすい速度で話せているか": {
        5: [
          "話す速度が適切で、非常に聞き取りやすいです。",
          "適切なペースで話しており、聴衆に理解しやすいです。",
          "話す速度がちょうど良く、聴衆が内容を把握しやすいです。"
        ],
        4: [
          "話す速度が良好で、ほとんど問題ありません。",
          "適切なペースで話しており、内容が理解しやすいです。",
          "話す速度が適切で、聴衆にスムーズに伝わっています。"
        ],
        3: [
          "話す速度は概ね良好ですが、部分的に速すぎる/遅すぎる箇所があります。",
          "話す速度は適切ですが、時折ペースが乱れることがあります。",
          "概ね適切な速度で話していますが、もう少し均一にすると良いでしょう。"
        ]
      },
      "表情を動かして話しているか": {
        5: [
          "表情豊かに話しており、聴衆とのコミュニケーションが優れています。",
          "適切な表情を用いて話しており、聴衆との親近感が高まっています。",
          "表情を効果的に使っており、聴衆にメッセージが伝わりやすいです。"
        ],
        4: [
          "適切な表情を用いて話しています。",
          "表情が良好で、聴衆とのコミュニケーションが円滑です。",
          "表情が適切に使われており、内容が伝わりやすいです。"
        ],
        3: [
          "表情は使用されていますが、さらに豊かにすると良いでしょう。",
          "表情をもう少し豊かにすることで、コミュニケーションが向上します。",
          "表情をもっと活用することで、プレゼンテーションがより魅力的になります。"
        ]
      }
    },
    "準備": {
      "原稿を覚えているか": {
        5: [
          "原稿を完全に覚えており、自然な話し方でプレゼンテーションを行っています。",
          "原稿をしっかり覚えており、スムーズに発表できています。",
          "原稿を覚えていることで、流暢なプレゼンテーションが可能です。"
        ],
        4: [
          "原稿をほとんど覚えており、自然な発表ができています。",
          "原稿の大部分を覚えており、プレゼンテーションがスムーズです。",
          "原稿を覚えているため、発表が一貫しています。"
        ],
        3: [
          "原稿を部分的に覚えていますが、さらなる練習が必要です。",
          "原稿を一部覚えており、全体的には話せていますが、改善が必要です。",
          "原稿を覚えていますが、もう少し自然な話し方が望まれます。"
        ]
      },
      "班員と協力できているか": {
        5: [
          "班員と完璧に協力できており、チームワークが優れています。",
          "班員との連携が非常に良好で、効果的に協力しています。",
          "班員との協力体制が整っており、スムーズに作業を進めています。"
        ],
        4: [
          "班員と良好に協力できており、チームワークが良いです。",
          "班員との連携が適切で、協力して作業を進めています。",
          "班員との協力体制が整っており、円滑にプロジェクトを進めています。"
        ],
        3: [
          "班員と協力していますが、さらに改善の余地があります。",
          "班員との連携はありますが、もう少し協力を強化すると良いでしょう。",
          "班員と協力していますが、コミュニケーションをさらに向上させると良いです。"
        ]
      },
      "計画的にできたか": {
        5: [
          "計画的に準備を進め、非常に組織的なプレゼンテーションができました。",
          "綿密な計画に基づいてプレゼンテーションを行い、非常に効率的でした。",
          "計画的な進行により、プレゼンテーションがスムーズに行われました。"
        ],
        4: [
          "計画的に準備を進め、良好なプレゼンテーションができました。",
          "計画に沿って準備を行い、プレゼンテーションが効率的でした。",
          "計画的な進行で、プレゼンテーションが円滑に行われました。"
        ],
        3: [
          "計画的に準備を進めましたが、もう少し詳細な計画が必要です。",
          "計画に沿って準備を行いましたが、改善の余地があります。",
          "計画的な準備はしましたが、さらに組織化すると良いでしょう。"
        ]
      },
      "質問内容を考えているか": {
        5: [
          "質問内容を十分に考慮しており、非常に適切な回答ができています。",
          "質問に対する準備が完璧で、的確な回答を提供しています。",
          "質問内容を深く理解し、適切に対応できています。"
        ],
        4: [
          "質問内容を適切に考慮しており、良好な回答ができています。",
          "質問に対する準備が整っており、適切に対応しています。",
          "質問内容を理解し、的確に回答しています。"
        ],
        3: [
          "質問内容を考慮していますが、回答に改善の余地があります。",
          "質問に対する準備はしていますが、もう少し詳細な回答が望まれます。",
          "質問内容を理解していますが、回答がやや不十分です。"
        ]
      }
    },
    "客のひきつけ": {
      "ジョークをいれているか": {
        5: [
          "適切なジョークを効果的に取り入れ、聴衆を笑顔にさせています。",
          "ジョークが巧みに使われており、プレゼンテーションに和やかな雰囲気を加えています。",
          "聴衆を引きつける素晴らしいジョークの使用が見られます。"
        ],
        4: [
          "ジョークが適切に使用されており、聴衆の関心を引きつけています。",
          "良いジョークの取り入れ方で、聴衆の興味を維持しています。",
          "適切なタイミングでジョークが使用され、プレゼンテーションが活気づいています。"
        ],
        3: [
          "ジョークを使用していますが、もう少し効果的に使うと良いでしょう。",
          "ジョークはありますが、聴衆との関係性にもう少し合わせると良いです。",
          "ジョークの使用はありますが、タイミングや内容を改善すると効果的です。"
        ]
      },
      "レーザーポインター等を使っているか": {
        5: [
          "レーザーポインターを効果的に使用し、視覚的に聴衆を引きつけています。",
          "視覚ツールの使用が巧みに行われており、プレゼンテーションがより魅力的です。",
          "レーザーポインターやその他のツールを効果的に活用しています。"
        ],
        4: [
          "レーザーポインターを適切に使用しており、視覚的なサポートがされています。",
          "視覚ツールの使用が良好で、聴衆の理解を助けています。",
          "レーザーポインターなどのツールを適切に活用しています。"
        ],
        3: [
          "レーザーポインターを使用していますが、さらに効果的に使うと良いでしょう。",
          "視覚ツールはありますが、使い方に改善の余地があります。",
          "レーザーポインターの使用はありますが、もっと効果的に活用できる可能性があります。"
        ]
      },
      "疑問形で話しかけているか": {
        5: [
          "効果的に疑問形を使用し、聴衆との対話を促進しています。",
          "適切な疑問形の使用で、聴衆の参加を引き出しています。",
          "疑問形を巧みに使って、聴衆の関心を引きつけています。"
        ],
        4: [
          "疑問形を適切に使用しており、聴衆との対話を促しています。",
          "効果的な疑問形の使用で、聴衆の関心を維持しています。",
          "疑問形を使って聴衆とのコミュニケーションが良好です。"
        ],
        3: [
          "疑問形を使用していますが、もう少し工夫すると良いでしょう。",
          "疑問形の使用はありますが、聴衆との対話をさらに促進すると良いです。",
          "疑問形を使っていますが、効果的な使い方に改善の余地があります。"
        ]
      },
      "観察とコミュニケーションをとれているか": {
        5: [
          "聴衆との積極的な観察とコミュニケーションが行われています。",
          "聴衆の反応を的確に捉え、効果的にコミュニケーションを取っています。",
          "聴衆とのコミュニケーションが非常に良好で、対話が活発です。"
        ],
        4: [
          "聴衆との観察とコミュニケーションが適切に行われています。",
          "聴衆の反応を捉え、効果的にコミュニケーションを取っています。",
          "聴衆との対話が良好で、コミュニケーションが円滑です。"
        ],
        3: [
          "聴衆とのコミュニケーションはありますが、さらに改善が必要です。",
          "聴衆の反応を捉えていますが、コミュニケーションの質を向上させると良いです。",
          "聴衆との対話がありますが、もっと積極的にコミュニケーションを取ると良いでしょう。"
        ]
      }
    },
    "スライド": {
      "分かりやすい英語でまとめられているか": {
        5: [
          "スライドが非常に明確な英語でまとめられており、理解しやすいです。",
          "わかりやすい英語表現でスライドが整理され、聴衆に伝わりやすいです。",
          "スライドの英語が非常に明瞭で、内容が一目で理解できます。"
        ],
        4: [
          "スライドが良好な英語でまとめられており、理解しやすいです。",
          "わかりやすい英語表現でスライドが整理されています。",
          "スライドの英語が明瞭で、内容が理解しやすいです。"
        ],
        3: [
          "スライドが概ね明確な英語でまとめられていますが、さらに改善が可能です。",
          "スライドの英語表現は良好ですが、もう少し明確にすると良いでしょう。",
          "スライドの英語は理解できますが、さらに簡潔にまとめると効果的です。"
        ]
      },
      "表、グラフ等を入れているか": {
        5: [
          "表やグラフが効果的に使用され、視覚的に情報が伝わります。",
          "豊富な視覚資料が活用されており、プレゼンテーションが非常に分かりやすいです。",
          "表やグラフが適切に配置され、情報が視覚的に整理されています。"
        ],
        4: [
          "表やグラフが適切に使用されており、視覚的なサポートがされています。",
          "視覚資料の使用が良好で、情報が整理されています。",
          "表やグラフが効果的に活用され、内容が理解しやすくなっています。"
        ],
        3: [
          "表やグラフが使用されていますが、さらに効果的に使うと良いでしょう。",
          "視覚資料はありますが、配置やデザインに改善の余地があります。",
          "表やグラフの使用はありますが、もう少し工夫すると視覚的な効果が高まります。"
        ]
      },
      "言いたいことを強調しているか": {
        5: [
          "言いたいことが非常に明確に強調されており、聴衆に伝わりやすいです。",
          "重要なポイントが効果的に強調されており、メッセージが明確です。",
          "言いたいことが強調され、プレゼンテーションの目的が明確に伝わっています。"
        ],
        4: [
          "言いたいことが適切に強調されており、メッセージが伝わりやすいです。",
          "重要なポイントがしっかりと強調されており、理解しやすいです。",
          "メッセージが明確に強調されており、聴衆に伝わっています。"
        ],
        3: [
          "言いたいことは強調されていますが、さらに効果的にすると良いでしょう。",
          "重要なポイントの強調はありますが、もう少し工夫が必要です。",
          "言いたいことが概ね強調されていますが、もう少し明確にすると良いです。"
        ]
      },
      "原稿とリンクしているか": {
        5: [
          "スライドと原稿が完全にリンクしており、一貫性があります。",
          "スライドと原稿が効果的に連携しており、内容が統一されています。",
          "スライドと原稿の整合性が非常に高く、プレゼンテーションが一貫しています。"
        ],
        4: [
          "スライドと原稿が適切にリンクしており、一貫性があります。",
          "スライドと原稿の連携が良好で、内容が統一されています。",
          "スライドと原稿がしっかりと連携しており、プレゼンテーションが一貫しています。"
        ],
        3: [
          "スライドと原稿はリンクしていますが、さらに整合性を高めると良いでしょう。",
          "スライドと原稿の連携はありますが、もう少し一貫性を持たせると良いです。",
          "スライドと原稿が概ね連携していますが、改善の余地があります。"
        ]
      }
    },
    "立ち振る舞い": {
      "前を向いて話しているか": {
        5: [
          "常に前を向いて話しており、聴衆とのアイコンタクトが素晴らしいです。",
          "前を向いて自信を持って話しており、聴衆との関係が良好です。",
          "前を向いて話すことで、聴衆とのコミュニケーションが非常に効果的です。"
        ],
        4: [
          "前を向いて話しており、聴衆とのアイコンタクトが適切です。",
          "前を向いて自信を持って話しており、聴衆との関係が良好です。",
          "前を向いて話すことで、聴衆とのコミュニケーションが円滑です。"
        ],
        3: [
          "前を向いて話していますが、もう少しアイコンタクトを増やすと良いでしょう。",
          "前を向いて話すことはできていますが、さらに自信を持つと良いです。",
          "前を向いて話していますが、もう少し積極的に聴衆と目を合わせると良いです。"
        ]
      },
      "ジェスチャーをしながら話しているか": {
        5: [
          "ジェスチャーが非常に自然で効果的に使用され、プレゼンテーションに深みを加えています。",
          "適切なジェスチャーを用いて話しており、聴衆の理解を助けています。",
          "ジェスチャーが効果的に使われており、プレゼンテーションがより魅力的です。"
        ],
        4: [
          "ジェスチャーが適切に使用されており、プレゼンテーションをサポートしています。",
          "良好なジェスチャーの使用で、内容がより伝わりやすくなっています。",
          "ジェスチャーが適切に使われており、聴衆とのコミュニケーションが円滑です。"
        ],
        3: [
          "ジェスチャーはありますが、さらに自然に使うと良いでしょう。",
          "ジェスチャーの使用はありますが、もう少し効果的に使うと良いです。",
          "ジェスチャーが適度に使われていますが、もう少し工夫すると効果的です。"
        ]
      },
      "自信を持って話しているか": {
        5: [
          "非常に自信を持って話しており、聴衆に安心感を与えています。",
          "自信に満ちた話し方で、聴衆の信頼を得ています。",
          "自信を持って話す姿勢が素晴らしく、プレゼンテーションが力強いです。"
        ],
        4: [
          "自信を持って話しており、聴衆に安心感を与えています。",
          "自信に満ちた話し方で、聴衆の信頼を得ています。",
          "自信を持って話す姿勢が良好で、プレゼンテーションが力強いです。"
        ],
        3: [
          "自信を持って話していますが、さらに自信を強化すると良いでしょう。",
          "自信は感じられますが、もう少し強調すると良いです。",
          "自信を持って話していますが、もっと積極的に表現すると良いです。"
        ]
      },
      "待っている人が壁に寄りかかったりしていない": {
        5: [
          "非常に安定した姿勢で立っており、聴衆に安心感を与えています。",
          "姿勢が非常に良く、プレゼンテーションに集中しています。",
          "安定した立ち方で、聴衆に信頼感を与えています。"
        ],
        4: [
          "安定した姿勢で立っており、プレゼンテーションに集中しています。",
          "姿勢が良好で、聴衆に信頼感を与えています。",
          "安定した立ち方で、プレゼンテーションがスムーズに進行しています。"
        ],
        3: [
          "姿勢は良好ですが、もう少し安定させると良いでしょう。",
          "立ち方に若干の不安定さがありますが、改善の余地があります。",
          "姿勢は適切ですが、もう少し安定させることでプレゼンテーションが向上します。"
        ]
      }
    }
  };
  
  const improvementPresets = {
    "原稿": {
      "わかりやすい英語で書かれているか": {
        3: {
          "message": [
            "さらに明確な英語表現を目指し、専門用語の使用を控えると良いでしょう。",
            "英語表現をより簡潔にし、専門用語の使用を減らすことを検討してください。",
            "もう少し明確な英語表現を取り入れると、原稿の理解度が向上します。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "英語表現を改善するために、文法や語彙の見直しを行いましょう。",
            "英語の文法や語彙を再確認し、表現力を向上させてください。",
            "英語表現の精度を高めるために、文法や語彙の見直しをおすすめします。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "わかりやすい英語表現を身につけるために、基礎からしっかりと学習しましょう。",
            "英語の基礎を再確認し、表現力を向上させる練習を始めましょう。",
            "英語表現の基礎を強化するために、基本的な学習を継続してください。"
          ],
          "priority": 2
        }
      },
      "分かりやすい構成で書かれているか": {
        3: {
          "message": [
            "構成をさらに整理し、論理的な流れを強化しましょう。",
            "論理的な構成をさらに明確にし、情報の流れを整えましょう。",
            "構成を再検討し、論理的な一貫性を高めるよう努めましょう。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "構成に一貫性を持たせるために、アウトラインを再検討しましょう。",
            "論理的な構成を強化するために、アウトラインを見直してください。",
            "構成の一貫性を高めるために、再度アウトラインを作成しましょう。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "明確な構成を作成するために、論理的な流れを計画的に構築しましょう。",
            "論理的な構成を計画的に構築し、全体の流れを明確にしましょう。",
            "プレゼンテーションの構成を再設計し、論理的な流れを確立しましょう。"
          ],
          "priority": 2
        }
      },
      "要点をまとめて書かれているか": {
        3: {
          "message": [
            "要点をより明確にするために、箇条書きや強調を活用しましょう。",
            "要点を簡潔にまとめるために、箇条書きやハイライトを使用してください。",
            "要点を強調するために、箇条書きやフォントの変更を取り入れましょう。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "要点の整理が必要です。重要なポイントを再度整理しましょう。",
            "要点を明確にするために、重要なポイントを再度確認してください。",
            "要点を効果的に伝えるために、ポイントを再整理しましょう。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "要点が不明確です。主なポイントを明確にまとめ直しましょう。",
            "要点を明確に伝えるために、主なポイントを再度整理してください。",
            "プレゼンテーションの要点を明確にするために、再度まとめ直しましょう。"
          ],
          "priority": 2
        }
      },
      "客観的なデータに基づいて書かれているか": {
        3: {
          "message": [
            "さらに信頼性を高めるために、追加の客観的データを参照しましょう。",
            "データの信頼性を向上させるために、さらに多くの客観的情報を取り入れてください。",
            "客観的なデータを追加することで、原稿の信頼性が向上します。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "客観的データの引用を増やし、情報の信頼性を向上させましょう。",
            "データの引用を増やすことで、原稿の信頼性を高めることができます。",
            "客観的なデータをより多く取り入れるようにしましょう。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "客観的なデータを積極的に取り入れ、原稿の信頼性を高めましょう。",
            "信頼性の高いデータを原稿に取り入れることで、説得力が増します。",
            "客観的なデータの活用を強化し、原稿の信頼性を向上させましょう。"
          ],
          "priority": 2
        }
      }
    },
    "話し方": {
      "抑揚をつける話しているか": {
        3: {
          "message": [
            "話し方に抑揚があるものの、さらなる工夫が可能です。",
            "抑揚はありますが、もう少し感情を込めると良いでしょう。",
            "抑揚が適度にありますが、さらに強調すると効果的です。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "抑揚が不足しており、単調に聞こえる部分があります。",
            "抑揚が少なく、聴衆の関心を引きつけにくいです。",
            "話し方が単調で、聴衆の興味を持続させるのが難しいです。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "抑揚がほとんどなく、聴衆の興味を引くのが難しい状態です。",
            "話し方が非常に単調で、聴衆の注意を引き付けるのが困難です。",
            "抑揚が全くなく、プレゼンテーションが退屈に感じられます。"
          ],
          "priority": 2
        }
      },
      "はっきりと大きな声で話しているか": {
        3: {
          "message": [
            "声の大きさは良好ですが、もう少し明瞭に話すと良いでしょう。",
            "声は大きいですが、明瞭さをさらに高めることができます。",
            "適切な声量ですが、発音の明瞭さを向上させると良いでしょう。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "声が小さく聞き取りにくい部分があります。",
            "声の大きさが不十分で、聴衆に届きにくいです。",
            "声が小さく、内容が伝わりにくいです。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "声が非常に小さく、聞き取るのが困難です。",
            "声量が不足しており、聴衆に伝わりません。",
            "非常に小さい声で話しており、聴衆が聞き取りにくいです。"
          ],
          "priority": 2
        }
      },
      "聞き取りやすい速度で話せているか": {
        3: {
          "message": [
            "話す速度は概ね良好ですが、部分的に速すぎる/遅すぎる箇所があります。",
            "話す速度は適切ですが、時折ペースが乱れることがあります。",
            "概ね適切な速度で話していますが、もう少し均一にすると良いでしょう。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "話す速度が速すぎるまたは遅すぎて、聞き取りにくい部分があります。",
            "話す速度が不適切で、内容が理解しにくいです。",
            "話す速度に変動があり、聴衆が内容を把握しづらいです。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "話す速度が適切でなく、全体的に聞き取りにくいです。",
            "非常に速いまたは非常に遅いペースで話しており、聴衆が内容を理解しにくいです。",
            "話す速度が不均一で、聴衆がついていけない状態です。"
          ],
          "priority": 2
        }
      },
      "表情を動かして話しているか": {
        3: {
          "message": [
            "表情は使用されていますが、さらに豊かにすると良いでしょう。",
            "表情をもう少し豊かにすることで、コミュニケーションが向上します。",
            "表情をもっと活用することで、プレゼンテーションがより魅力的になります。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "表情が少なく、コミュニケーションがやや不足しています。",
            "表情が控えめで、聴衆との関係性が弱まっています。",
            "表情の使用が少なく、メッセージが伝わりにくいです。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "表情がほとんどなく、コミュニケーションに課題があります。まずは笑顔の練習をしましょう。",
            "表情が固まったままになっています。基本の表情トレーニングから始めてください。",
            "まったく表情がない状態で話しているようです。実際の会話で表情を意識するところから練習を始めましょう。"
          ],
          "priority": 2
        }
      }
    },
    "客のひきつけ": {
      "ジョークをいれているか": {
        3: {
          "message": [
            "ジョークを使用していますが、もう少し効果的に使うと良いでしょう。",
            "ジョークはありますが、聴衆との関係性にもう少し合わせると良いです。",
            "ジョークの使用はありますが、タイミングや内容を改善すると効果的です。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "ジョークの使用が少なく、聴衆の興味を引きつけにくいです。",
            "ジョークが適切に使われておらず、プレゼンテーションが堅苦しく感じられます。",
            "ジョークの取り入れ方に課題があり、聴衆の関心を引きつけられていません。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "ジョークを全く使用しておらず、聴衆の興味を引きつける工夫が見られません。",
            "ジョークが全くなく、プレゼンテーションが非常に単調です。",
            "ジョークを全く取り入れず、聴衆との距離感が感じられます。"
          ],
          "priority": 2
        }
      },
      "レーザーポインター等を使っているか": {
        3: {
          "message": [
            "レーザーポインターを使用していますが、さらに効果的に使うと良いでしょう。",
            "視覚ツールはありますが、使い方に改善の余地があります。",
            "レーザーポインターの使用はありますが、もっと効果的に活用できる可能性があります。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "レーザーポインターの使用が少なく、視覚的なサポートが不足しています。",
            "視覚資料が不十分で、情報が整理されていません。",
            "レーザーポインターの使用が効果的でなく、情報が伝わりにくいです。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "レーザーポインターを全く使用しておらず、視覚的なサポートが見られません。",
            "視覚資料の使用が全くなく、プレゼンテーションが非常に単調です。",
            "レーザーポインターなどの視覚資料が全く取り入れられていません。"
          ],
          "priority": 2
        }
      },
      "疑問形で話しかけているか": {
        3: {
          "message": [
            "疑問形を使用していますが、もう少し工夫すると良いでしょう。",
            "疑問形の使用はありますが、聴衆との対話をさらに促進すると良いです。",
            "疑問形を使っていますが、効果的な使い方に改善の余地があります。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "疑問形が少ないため、一方的な印象になりがちです。簡単な質問でも良いので投げかけましょう。",
            "聴衆の注意を引くために、定期的に疑問形で話しかける工夫をしてみてください。",
            "一方的に説明するだけでなく、疑問やクイズ形式を取り入れて参加意識を高めましょう。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "全く疑問形を使っておらず、聴衆との対話が見られません。",
            "疑問形が全くなく、プレゼンテーションが一方通行になっています。",
            "疑問形を全く取り入れておらず、聴衆とのインタラクションがありません。"
          ],
          "priority": 2
        }
      },
      "観察とコミュニケーションをとれているか": {
        3: {
          "message": [
            "聴衆とのコミュニケーションはありますが、さらに改善が必要です。",
            "聴衆の反応を捉えていますが、コミュニケーションの質を向上させると良いです。",
            "聴衆との対話がありますが、もっと積極的にコミュニケーションを取ると良いでしょう。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "聴衆とのコミュニケーションが不足しており、反応を捉えきれていません。",
            "聴衆との対話が少なく、コミュニケーションに課題があります。",
            "聴衆とのコミュニケーションが不十分で、反応を引き出せていません。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "聴衆とのコミュニケーションが全く行われておらず、反応が見られません。",
            "聴衆との対話が全くなく、プレゼンテーションが一方通行です。",
            "聴衆とのコミュニケーションが欠如しており、反応が全くありません。"
          ],
          "priority": 2
        }
      }
    },
    "スライド": {
      "分かりやすい英語でまとめられているか": {
        5: [
          "スライドが非常に明確な英語でまとめられており、理解しやすいです。",
          "わかりやすい英語表現でスライドが整理され、聴衆に伝わりやすいです。",
          "スライドの英語が非常に明瞭で、内容が一目で理解できます。"
        ],
        4: [
          "スライドが良好な英語でまとめられており、理解しやすいです。",
          "わかりやすい英語表現でスライドが整理されています。",
          "スライドの英語が明瞭で、内容が理解しやすいです。"
        ],
        3: {
          "message": [
            "スライドが概ね明確な英語でまとめられていますが、さらに改善が可能です。",
            "スライドの英語表現は良好ですが、もう少し明確にすると良いでしょう。",
            "スライドの英語は理解できますが、さらに簡潔にまとめると効果的です。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "スライドの英語表現が不明瞭で、理解しにくい部分があります。",
            "スライドの英語が一部不明瞭で、情報が伝わりにくいです。",
            "スライドの英語表現に改善の余地があり、内容が理解しづらいです。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "わかりやすい英語表現が不十分で、スライドが理解しにくいです。",
            "スライドの英語が非常に不明瞭で、聴衆が内容を理解しにくいです。",
            "スライドの英語表現が全く不十分で、内容が伝わりません。"
          ],
          "priority": 2
        }
      },
      "表、グラフ等を入れているか": {
        5: [
          "表やグラフが効果的に使用され、視覚的に情報が伝わります。",
          "豊富な視覚資料が活用されており、プレゼンテーションが非常に分かりやすいです。",
          "表やグラフが適切に配置され、情報が視覚的に整理されています。"
        ],
        4: [
          "表やグラフが適切に使用されており、視覚的なサポートがされています。",
          "視覚資料の使用が良好で、情報が整理されています。",
          "表やグラフが効果的に活用され、内容が理解しやすくなっています。"
        ],
        3: {
          "message": [
            "表やグラフが使用されていますが、さらに効果的に使うと良いでしょう。",
            "視覚資料はありますが、配置やデザインに改善の余地があります。",
            "表やグラフの使用はありますが、もう少し工夫すると視覚的な効果が高まります。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "表やグラフの使用が少なく、視覚的なサポートが不足しています。",
            "視覚資料が不十分で、情報が整理されていません。",
            "表やグラフの使用が効果的でなく、情報が伝わりにくいです。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "表やグラフが全く使用されておらず、視覚的なサポートが見られません。",
            "視覚資料の使用が全くなく、プレゼンテーションが非常に単調です。",
            "表やグラフなどの視覚資料が全く取り入れられていません。"
          ],
          "priority": 2
        }
      },
      "言いたいことを強調しているか": {
        5: [
          "言いたいことが非常に明確に強調されており、聴衆に伝わりやすいです。",
          "重要なポイントが効果的に強調されており、メッセージが明確です。",
          "言いたいことが強調され、プレゼンテーションの目的が明確に伝わっています。"
        ],
        4: [
          "言いたいことが適切に強調されており、メッセージが伝わりやすいです。",
          "重要なポイントがしっかりと強調されており、理解しやすいです。",
          "メッセージが明確に強調されており、聴衆に伝わっています。"
        ],
        3: {
          "message": [
            "言いたいことは強調されていますが、さらに効果的にすると良いでしょう。",
            "重要なポイントの強調はありますが、もう少し工夫が必要です。",
            "言いたいことが概ね強調されていますが、もう少し明確にすると良いです。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "言いたいことの強調が不十分で、メッセージが伝わりにくいです。",
            "重要なポイントの強調が不足しており、聴衆に伝わりにくいです。",
            "言いたいことが十分に強調されておらず、メッセージが曖昧です。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "言いたいことが明確に強調されておらず、メッセージが伝わりません。",
            "重要なポイントが全く強調されておらず、聴衆に伝わりません。",
            "言いたいことが全く強調されておらず、プレゼンテーションが曖昧です。"
          ],
          "priority": 2
        }
      },
      "原稿とリンクしているか": {
        5: [
          "スライドと原稿が完全にリンクしており、一貫性があります。",
          "スライドと原稿が効果的に連携しており、内容が統一されています。",
          "スライドと原稿の整合性が非常に高く、プレゼンテーションが一貫しています。"
        ],
        4: [
          "スライドと原稿が適切にリンクしており、一貫性があります。",
          "スライドと原稿の連携が良好で、内容が統一されています。",
          "スライドと原稿がしっかりと連携しており、プレゼンテーションが一貫しています。"
        ],
        3: {
          "message": [
            "スライドと原稿はリンクしていますが、さらに整合性を高めると良いでしょう。",
            "スライドと原稿の連携はありますが、もう少し一貫性を持たせると良いです。",
            "スライドと原稿が概ね連携していますが、改善の余地があります。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "スライドと原稿のリンクが不十分で、一貫性が欠けています。",
            "スライドと原稿が適切に連携しておらず、内容に矛盾があります。",
            "スライドと原稿の整合性が不足しており、プレゼンテーションが混乱しています。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "スライドと原稿が全くリンクしておらず、一貫性がありません。",
            "スライドと原稿が無関係で、プレゼンテーションに一貫性が欠けています。",
            "スライドと原稿の内容が全く一致しておらず、情報に矛盾があります。"
          ],
          "priority": 2
        }
      }
    },
    "立ち振る舞い": {
      "前を向いて話しているか": {
        5: [
          "常に前を向いて話しており、聴衆とのアイコンタクトが素晴らしいです。",
          "前を向いて自信を持って話しており、聴衆との関係が良好です。",
          "前を向いて話すことで、聴衆とのコミュニケーションが非常に効果的です。"
        ],
        4: [
          "前を向いて話しており、聴衆とのアイコンタクトが適切です。",
          "前を向いて自信を持って話しており、聴衆との関係が良好です。",
          "前を向いて話すことで、聴衆とのコミュニケーションが円滑です。"
        ],
        3: {
          "message": [
            "前を向いて話していますが、もう少しアイコンタクトを増やすと良いでしょう。",
            "前を向いて話すことはできていますが、さらに自信を持つと良いです。",
            "前を向いて話していますが、もう少し積極的に聴衆と目を合わせると良いです。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "姿勢が不安定で、聴衆とのアイコンタクトが不足しています。",
            "前を向いて話すことが難しく、聴衆との関係が弱まっています。",
            "前を向いて話す姿勢が不十分で、コミュニケーションに課題があります。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "前を向いて話しておらず、聴衆とのアイコンタクトが全くありません。",
            "姿勢が悪く、前を向いて話すことができていません。",
            "聴衆と目を合わせず、前を向いて話す姿勢が見られません。"
          ],
          "priority": 2
        }
      },
      "ジェスチャーをしながら話しているか": {
        3: {
          "message": [
            "ジェスチャーはありますが、さらに自然に使うと良いでしょう。",
            "ジェスチャーの使用はありますが、もう少し効果的に使うと良いです。",
            "ジェスチャーが適度に使われていますが、もう少し工夫すると効果的です。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "ジェスチャーの使用が少なく、プレゼンテーションに表現力が不足しています。",
            "ジェスチャーが不十分で、内容が伝わりにくいです。",
            "ジェスチャーの取り入れ方に課題があり、プレゼンテーションが単調です。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "ジェスチャーを全く使用しておらず、プレゼンテーションに表現力が欠けています。",
            "ジェスチャーが全くなく、プレゼンテーションが非常に静的です。",
            "ジェスチャーの使用が全く見られず、プレゼンテーションが無機質に感じられます。"
          ],
          "priority": 2
        }
      },
      "自信を持って話しているか": {
        3: {
          "message": [
            "自信を持って話していますが、さらに自信を強化すると良いでしょう。",
            "自信は感じられますが、もう少し強調すると良いです。",
            "自信を持って話していますが、もっと積極的に表現すると良いです。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "自信が不足しており、プレゼンテーションに影響を与えています。",
            "自信を持って話すことが難しく、聴衆に不安感を与えています。",
            "自信がほとんど感じられず、プレゼンテーションが弱々しく見えます。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "自信を持って話しておらず、プレゼンテーションに大きな影響を与えています。",
            "非常に自信が感じられず、聴衆に不安感を与えています。",
            "自信が全く感じられず、プレゼンテーションが不安定に見えます。"
          ],
          "priority": 2
        }
      },
      "待っている人が壁に寄りかかったりしていない": {
        3: {
          "message": [
            "姿勢は良好ですが、もう少し安定させると良いでしょう。",
            "立ち方に若干の不安定さがありますが、改善の余地があります。",
            "姿勢は適切ですが、もう少し安定させることでプレゼンテーションが向上します。"
          ],
          "priority": 2
        },
        2: {
          "message": [
            "姿勢が不安定で、プレゼンテーションに支障が出ています。",
            "立ち方が不自然で、聴衆に不信感を与える可能性があります。",
            "姿勢が不十分で、プレゼンテーションが不安定に見えます。"
          ],
          "priority": 2
        },
        1: {
          "message": [
            "姿勢が非常に不安定で、プレゼンテーションに大きな支障をきたしています。",
            "立ち方が非常に不自然で、聴衆の注意を引き付けるのが困難です。",
            "姿勢が全く安定しておらず、プレゼンテーションが混乱しています。"
          ],
          "priority": 2
        }
      }
    }
  };
  
  const malkovTemplates = [
    "まず、{categories}において、{skills}が{status}です。",
    "まずは、{categories}において、{skills}が{status}と感じられました。",
    "まず、{categories}において、{skills}が{status}ように見受けられます。",
    "最初に、{categories}において、{skills}が{status}ことが確認できました。",
    "最初に、{categories}において、{skills}が{status}と感じられます。"
  ];
  
  const skillsStatusTemplates = [
    "基本的なプレゼンテーションの技術",
    "プレゼンテーションの基本スキル",
    "基本的なプレゼン技術",
    "基礎的なプレゼンテーションスキル",
    "プレゼンテーションの基本的な技術"
  ];
  
  const statusTemplates = [
    "不足しているように感じられました",
    "不足しています",
    "不足していることが見受けられました",
    "不十分です",
    "不足が認められます"
  ];
  
  /**
   * フィードバック生成関数
   * 
   * @param {Object} evaluation - 評価データ。カテゴリごとのサブカテゴリとスコアを含むオブジェクト。
   * @param {Object} encouragement - 応援メッセージのプリセット。
   * @param {Object} improvement - 改善メッセージのプリセット。
   * @returns {string} 生成されたフィードバックテキスト。
   */
  function generateFeedback(evaluation, encouragement, improvement) {
    const feedback = {
      "全体的な評価": "",
      "分析的な評価": "",
      "次のステップの提案": "",
      "メッセージ": ""
    };
  
    // カテゴリごとの平均スコアを計算
    const categoryAverages = {};
    for (const category in evaluation) {
      if (evaluation.hasOwnProperty(category)) {
        const subcategories = evaluation[category];
        const scores = Object.values(subcategories);
        const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
        categoryAverages[category] = avgScore;
      }
    }
  
    // 全体的な評価の作成
    const strengths = [];
    const areasForImprovement = [];
    for (const category in categoryAverages) {
      if (categoryAverages.hasOwnProperty(category)) {
        const avg = categoryAverages[category];
        if (avg >= 4) {
          strengths.push(`${category}において優れた成果を達成しました。`);
        } else if (avg >= 3) {
          strengths.push(`${category}において良好な成果を達成しましたが、さらなる改善の余地があります。`);
          areasForImprovement.push(category);
        } else {
          areasForImprovement.push(category);
        }
      }
    }
  
    if (strengths.length > 0) {
      feedback["全体的な評価"] = "全体的に、" + strengths.join(" ");
    }
    if (areasForImprovement.length > 0) {
      if (feedback["全体的な評価"]) {
        feedback["全体的な評価"] += " 一方で、" + areasForImprovement.join("、") + "に改善の余地があります。";
      } else {
        feedback["全体的な評価"] = "全体的に、" + areasForImprovement.join("、") + "に改善の余地があります。";
      }
    }
  
    // 分析的な評価の作成
    const analysisFeedback = [];
    for (const category in evaluation) {
      if (evaluation.hasOwnProperty(category)) {
        analysisFeedback.push(`**${category}**:`);
        const subcategories = evaluation[category];
        for (const subcategory in subcategories) {
          if (subcategories.hasOwnProperty(subcategory)) {
            const score = subcategories[subcategory];
            if (score >= 3) {
              // encouragement（応援）メッセージを取得
              const msgList = encouragement[category]?.[subcategory]?.[score] || [];
              if (msgList.length > 0) {
                const chosen = msgList[Math.floor(Math.random() * msgList.length)];
                analysisFeedback.push(`- ${chosen}`);
              }
            } else {
              // improvement（改善）メッセージを取得
              const msgDict = improvement[category]?.[subcategory]?.[score] || {};
              const msgList = msgDict.message || [];
              if (msgList.length > 0) {
                const chosen = msgList[Math.floor(Math.random() * msgList.length)];
                analysisFeedback.push(`- ${chosen}`);
              }
            }
          }
        }
        analysisFeedback.push(""); // 空行で区切る
      }
    }
    feedback["分析的な評価"] = analysisFeedback.join("\n").trim();
  
    // 次のステップの提案
    const nextSteps = [];
    for (const category in evaluation) {
      if (evaluation.hasOwnProperty(category)) {
        const subcategories = evaluation[category];
        for (const subcategory in subcategories) {
          if (subcategories.hasOwnProperty(subcategory)) {
            const score = subcategories[subcategory];
            if (score < 3) {
              const msgDict = improvement[category]?.[subcategory]?.[score] || {};
              const msgList = msgDict.message || [];
              const priority = msgDict.priority || 5;
              if (msgList.length > 0) {
                const chosen = msgList[Math.floor(Math.random() * msgList.length)];
                nextSteps.push({
                  "category": category,
                  "subcategory": subcategory,
                  "message": chosen,
                  "priority": priority
                });
              }
            }
          }
        }
      }
    }
  
    // 優先度の高い順にソート（数字が小さいほど優先度高）
    nextSteps.sort((a, b) => a.priority - b.priority);
  
    // スコアが低い項目があれば、malkovテンプレートを1回使う
    if (nextSteps.length > 0) {
      // カテゴリ名をまとめる
      const categoriesList = nextSteps.map(step => step.category);
      // 重複を除去しつつ順番は維持
      const seen = [];
      const uniqueCategories = categoriesList.filter(c => {
        if (!seen.includes(c)) {
          seen.push(c);
          return true;
        }
        return false;
      });
      const categories = uniqueCategories.join("、");
  
      const skills = skillsStatusTemplates[Math.floor(Math.random() * skillsStatusTemplates.length)];
      const status = statusTemplates[Math.floor(Math.random() * statusTemplates.length)];
      const malkovTemplate = malkovTemplates[Math.floor(Math.random() * malkovTemplates.length)];
      const feedbackSentence = malkovTemplate.replace("{categories}", categories)
                                              .replace("{skills}", skills)
                                              .replace("{status}", status);
  
      if (feedback["全体的な評価"]) {
        feedback["全体的な評価"] += " " + feedbackSentence;
      } else {
        feedback["全体的な評価"] = feedbackSentence;
      }
    }
  
    // 個別提案をまとめる
    if (nextSteps.length > 0) {
      const stepMessages = [];
      for (let i = 0; i < nextSteps.length; i++) {
        const step = nextSteps[i];
        let prefix = "";
        if (i === 0) {
          prefix = "\n\nまずは";
        } else {
          prefix = "\n\n次に";
        }
        stepMessages.push(`${prefix}、**${step.category} - ${step.subcategory}**: ${step.message}`);
      }
      feedback["次のステップの提案"] = "\n次に向けて、以下の点に取り組むことをお勧めします。\n" + stepMessages.join("\n");
    }
  
    // 最後のメッセージ
    feedback["メッセージ"] = (
      "お疲れさまでした！今回のプレゼンテーションでは多くの点で努力が見られました。"
      + "継続的な改善を通じて、さらに素晴らしい成果を期待しています。頑張ってください！"
    );
  
    // 連結して最終テキストに
    let feedbackText = "";
    const sections = ["全体的な評価", "分析的な評価", "次のステップの提案", "メッセージ"];
    sections.forEach(section => {
      if (feedback[section]) {
        feedbackText += `### **${section}**\n${feedback[section]}\n\n`;
      }
    });
  
    return feedbackText.trim();
  }
  
  /**
   * YAMLをJavaScriptオブジェクトに解析する関数。
   *
   * @param {string} yaml - 解析するYAML文字列。
   * @return {Object} 解析されたJavaScriptオブジェクト。
   * @throws {Error} YAMLの形式が不正な場合にエラーをスロー。
   */
  function parseYAML(yaml) {
    const lines = yaml.split('\n').map(line => line.replace(/\r$/, '')); // 改行文字を削除
    let currentIndex = 0;
  
    /**
     * 指定されたインデントレベルでブロックを再帰的に解析する関数。
     *
     * @param {number} indentLevel - 現在のインデントレベル（スペース数）。
     * @return {Object|Array} 解析されたJavaScriptオブジェクトまたは配列。
     */
    function parseBlock(indentLevel) {
      let result = {};
      let array = null;
  
      while (currentIndex < lines.length) {
        let line = lines[currentIndex];
  
        // 空行をスキップ
        if (/^\s*$/.test(line)) {
          currentIndex++;
          continue;
        }
  
        // 現在の行のインデントを取得
        const indentMatch = line.match(/^(\s*)/);
        const indent = indentMatch ? indentMatch[1].length : 0;
  
        // 現在のブロックのインデントよりも小さい場合、ブロックの終了
        if (indent < indentLevel) {
          break;
        }
  
        // 行をトリム
        line = line.trim();
  
        if (line.startsWith('- ')) {
          // リスト項目の処理
          if (!array) {
            array = [];
            if (Object.keys(result).length > 0) {
              throw new Error(`Mixed object and array types at line ${currentIndex + 1}: ${line}`);
            }
          }
  
          const item = line.substring(2).trim();
          if (item === '') {
            currentIndex++;
            const nested = parseBlock(indentLevel + 2);
            array.push(nested);
          } else if (item.endsWith(':')) {
            const key = item.slice(0, -1).trim();
            currentIndex++;
            const nested = parseBlock(indentLevel + 2);
            let obj = {};
            obj[key] = nested;
            array.push(obj);
          } else {
            array.push(parseValue(item));
            currentIndex++;
          }
        } else {
          // キー-値ペアの処理
          const colonIndex = line.indexOf(':');
          if (colonIndex === -1) {
            throw new Error(`Invalid YAML format at line ${currentIndex + 1}: ${line}`);
          }
  
          const key = line.substring(0, colonIndex).trim();
          let value = line.substring(colonIndex + 1).trim();
  
          if (value === '') {
            currentIndex++;
            if (currentIndex < lines.length) {
              const nextLine = lines[currentIndex];
              const nextIndentMatch = nextLine.match(/^(\s*)/);
              const nextIndent = nextIndentMatch ? nextIndentMatch[1].length : 0;
  
              if (nextIndent > indentLevel) {
                const peekedLine = nextLine.trim();
                if (peekedLine.startsWith('- ')) {
                  result[key] = parseBlock(indentLevel + 2);
                } else {
                  result[key] = parseBlock(indentLevel + 2);
                }
              } else {
                result[key] = {};
              }
            } else {
              result[key] = {};
            }
          } else {
            result[key] = parseValue(value);
            currentIndex++;
          }
        }
      }
  
      return array ? array : result;
    }
  
    /**
     * YAMLの値を適切なJavaScript型に変換する関数。
     *
     * @param {string} value - YAMLの値を表す文字列。
     * @return {*} 変換された値。
     */
    function parseValue(value) {
      if (!isNaN(value)) {
        return Number(value);
      }
  
      if (value.toLowerCase() === 'true') return true;
      if (value.toLowerCase() === 'false') return false;
      if (value.toLowerCase() === 'null') return null;
  
      return value;
    }
  
    return parseBlock(0);
  }
  
  /**
   * フィードバック生成関数
   * 
   * @param {string} yamlInput - 評価データを含むYAML形式の文字列。
   * @returns {Object} フィードバック結果。成功時はフィードバックテキストを含み、エラー時はエラーメッセージを含む。
   */
  function createFeedbackFromYAML(yamlInput) {
    try {
      const parsedData = parseYAML(yamlInput);
  
      // 「評価」部分を取り出してオブジェクトに変換
      const evaluationArray = parsedData["評価"] || [];
      const evaluationData = {};
  
      evaluationArray.forEach(categoryObj => {
        for (const category in categoryObj) {
          if (categoryObj.hasOwnProperty(category)) {
            evaluationData[category] = categoryObj[category];
          }
        }
      });
  
      if (Object.keys(evaluationData).length === 0) {
        return { success: false, message: "評価データが正しくありません。" };
      }
  
      // フィードバック生成
      const feedbackText = generateFeedback(
        evaluationData,
        encouragementPresets,
        improvementPresets
      );
  
      return { success: true, feedback: feedbackText };
  
    } catch (error) {
      console.error("Error generating feedback:", error);
      return { success: false, message: "エラーが発生しました: " + error.message };
    }
  }
  
/**
 * フィードバック生成関数
 * 
 * @param {string} yamlInput - 評価データを含むYAML形式の文字列。
 * @returns {Object} フィードバック結果。成功時はフィードバックテキストを含み、エラー時はエラーメッセージを含む。
 */
function createFeedbackFromYAML(yamlInput) {
    try {
        const parsedData = parseYAML(yamlInput);

        // 「評価」部分を取り出してオブジェクトに変換
        const evaluationArray = parsedData["評価"] || [];
        const evaluationData = {};

        evaluationArray.forEach(categoryObj => {
            for (const category in categoryObj) {
                if (categoryObj.hasOwnProperty(category)) {
                    evaluationData[category] = categoryObj[category];
                }
            }
        });

        if (Object.keys(evaluationData).length === 0) {
            return { success: false, message: "評価データが正しくありません。" };
        }

        // フィードバック生成
        const feedbackText = generateFeedback(
            evaluationData,
            encouragementPresets,
            improvementPresets
        );

        return { success: true, feedback: feedbackText };

    } catch (error) {
        console.error("Error generating feedback:", error);
        return { success: false, message: "エラーが発生しました: " + error.message };
    }
}

  // モジュールとしてエクスポート（Node.jsの場合）
  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = {
      generateFeedback,
      parseYAML,
      createFeedbackFromYAML,
      encouragementPresets,
      improvementPresets,
      malkovTemplates,
      skillsStatusTemplates,
      statusTemplates
    };
  }
  
  // ブラウザ環境の場合はグローバルオブジェクトにアタッチ
  if (typeof window !== 'undefined') {
    window.FeedbackGenerator = {
      generateFeedback,
      parseYAML,
      createFeedbackFromYAML,
      encouragementPresets,
      improvementPresets,
      malkovTemplates,
      skillsStatusTemplates,
      statusTemplates
    };
  }
  </script>
    <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    console.debug("Application initialized. Starting to define utility functions.");

    // Utility function: Convert progress (1-5) to percentage
    const scaleProgress = (progress) => {
        console.debug(`scaleProgress called with progress: ${progress}`);
        return ((progress - 1) / 4) * 100;
    };

    // Utility: Get current timestamp
    const getCurrentTimestamp = () => {
        const timestamp = new Date().toISOString();
        console.debug(`getCurrentTimestamp called. Timestamp: ${timestamp}`);
        return timestamp;
    };

    /***********************************************
     *  ローカルストレージ関連（スナップショット）
     ***********************************************/
    const saveSnapshotFunction = (currentProgress) => {
        console.debug("saveSnapshotFunction called with currentProgress:", currentProgress);
        const userName = localStorage.getItem('current_user') || 'default_user';
        console.debug(`Current user: ${userName}`);
        const snapshotsKey = `snapshots_${userName}`;
        const snapshots = JSON.parse(localStorage.getItem(snapshotsKey)) || [];

        const newSnapshot = {
            timestamp: getCurrentTimestamp(),
            data: currentProgress
        };
        console.debug("New snapshot to be saved:", newSnapshot);

        snapshots.push(newSnapshot);
        localStorage.setItem(snapshotsKey, JSON.stringify(snapshots));
        console.debug("New snapshot saved successfully.");
    };

    const restoreSnapshot = (snapshotIndex) => {
        console.debug(`restoreSnapshot called with snapshotIndex: ${snapshotIndex}`);
        const userName = localStorage.getItem('current_user') || 'default_user';
        console.debug(`Current user: ${userName}`);
        const snapshotsKey = `snapshots_${userName}`;
        const snapshots = JSON.parse(localStorage.getItem(snapshotsKey)) || [];
        console.debug(`Available snapshots for restoration:`, snapshots);
        const snapshot = snapshots[snapshotIndex];
        if (snapshot) {
            console.debug(`Snapshot found at index ${snapshotIndex}:`, snapshot);
            return snapshot.data;
        }
        console.warn(`No snapshot found at index ${snapshotIndex}.`);
        return null;
    };

    const deleteSnapshot = (snapshotIndex) => {
        console.debug(`deleteSnapshot called with snapshotIndex: ${snapshotIndex}`);
        const userName = localStorage.getItem('current_user') || 'default_user';
        console.debug(`Current user: ${userName}`);
        const snapshotsKey = `snapshots_${userName}`;
        const snapshots = JSON.parse(localStorage.getItem(snapshotsKey)) || [];
        console.debug(`Snapshots before deletion:`, snapshots);
        snapshots.splice(snapshotIndex, 1);
        localStorage.setItem(snapshotsKey, JSON.stringify(snapshots));
        console.debug(`Snapshots after deletion:`, snapshots);
    };

    /***********************************************
     *  エクスポート／インポート関連
     ***********************************************/
    // YAMLエクスポート => "テキストとしてエクスポートする"
    const handleExportYAML = (userName, setExportedYaml, ifFile) => {
        console.debug(`handleExportYAML called with userName: ${userName}`);
        const snapshotsKey = `snapshots_${userName}`;
        const snapshots = JSON.parse(localStorage.getItem(snapshotsKey)) || [];
        console.debug(`Snapshots retrieved for YAML export:`, snapshots);
        const savedSelfEvaluation = localStorage.getItem(`self_evaluation_${userName}`) || '';
        console.debug(`Self-Evaluation retrieved: ${savedSelfEvaluation}`);
        // 最新スナップショットのデータを採用
        const latestSnapshot = snapshots[snapshots.length - 1]?.data || {};
        console.debug("Latest snapshot data:", latestSnapshot);

        // YAMLにしたい構造を作成
        const transformedData = {
            評価: [],
            感想: savedSelfEvaluation
        };
        console.debug("Initial transformedData:", transformedData);

        // window.globalData を利用してカテゴリ・項目名を取り出し
        window.globalData.forEach(category => {
            console.debug(`Processing category: ${category.label}`);
            const categoryData = {};
            const categoryItems = {};

            category.children.forEach(item => {
                const progress = latestSnapshot[`progress-${item.id}`] || 1;
                console.debug(`Processing item: ${item.label}, progress: ${progress}`);
                categoryItems[item.label] = progress;
            });

            categoryData[category.label] = categoryItems;
            transformedData.評価.push(categoryData);
            console.debug(`CategoryData after processing ${category.label}:`, categoryData);
        });

        console.debug("Final transformedData before YAML conversion:", transformedData);

        const yamlStr = jsyaml.dump(transformedData, {
            indent: 2,
            lineWidth: -1,
            noRefs: true
        });
        console.debug("YAML string generated:", yamlStr);

        // ダウンロード
        if(ifFile){
            const blob = new Blob([yamlStr], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'progress_backup.yaml';
            console.debug("Initiating YAML file download.");
            link.click();
        };

        // exportedYamlにセット
        setExportedYaml(yamlStr);
        console.debug("exportedYaml state updated.");
    };

    // JSONインポート
    const handleImportJSON = (file, userName, onImportSuccess) => {
        console.debug(`handleImportJSON called with file:`, file, `userName: ${userName}`);
        const reader = new FileReader();
        reader.onload = (e) => {
            console.debug("FileReader onload triggered.");
            try {
                const importData = JSON.parse(e.target.result);
                console.debug("Parsed importData:", importData);
                if (importData.snapshots) {
                    const snapshotsKey = `snapshots_${userName}`;
                    localStorage.setItem(snapshotsKey, JSON.stringify(importData.snapshots));
                    console.debug(`Snapshots imported and saved under key: ${snapshotsKey}`);
                }
                onImportSuccess();
                console.debug("Import successful. onImportSuccess callback executed.");
            } catch (error) {
                console.error('Import Error:', error);
                alert('インポートに失敗しました。正しいJSONファイルを選択してください。');
            }
        };
        reader.onerror = (error) => {
            console.error('FileReader Error:', error);
            alert('ファイルの読み込み中にエラーが発生しました。');
        };
        reader.readAsText(file);
        console.debug("FileReader readAsText called.");
    };

    /***********************************************
     *  スナップショット一覧コンポーネント
     ***********************************************/
    const SnapshotList = ({ snapshots, onRestore, onDelete }) => {
        console.debug("SnapshotList component rendered with snapshots:", snapshots);
        return (
            <div className="snapshot-list">
                {snapshots.length > 0 ? (
                    <ul>
                        {snapshots.map((snapshot, index) => (
                            <li key={snapshot.timestamp} className="snapshot-item">
                                <span>{new Date(snapshot.timestamp).toLocaleString()}</span>
                                <div>
                                    <button onClick={() => {
                                        console.debug(`Restore button clicked for snapshot index: ${index}`);
                                        onRestore(index);
                                    }}>復元</button>
                                    <button onClick={() => {
                                        console.debug(`Delete button clicked for snapshot index: ${index}`);
                                        onDelete(index);
                                    }}>削除</button>
                                </div>
                            </li>
                        ))}
                    </ul>
                ) : (
                    <p>保存されたスナップショットはありません。</p>
                )}
            </div>
        );
    };

    /***********************************************
     *  フィードバック生成コンポーネント
     ***********************************************/
    const FeedbackGeneratorTMP = ({ exportedYaml }) => {
        console.debug("FeedbackGenerator component rendered with exportedYaml:", exportedYaml);
        const [feedbackContent, setFeedbackContent] = useState('');
        const [isLoading, setIsLoading] = useState(false);
        const [yamlInput, setYamlInput] = useState('');

        useEffect(() => {
            console.debug("あFeedbackGenerator useEffect triggered with exportedYaml:", exportedYaml);
            if (exportedYaml) {
                setYamlInput(exportedYaml);
                generateFeedbackComponent(exportedYaml);
            }
        }, [exportedYaml]);

        const generateFeedbackComponent = async (yamlData) => {
            console.debug("いgenerateFeedback called with yamlData:", yamlData);
            if (yamlData.trim() === "") {
                console.warn("YAML data is empty.");
                setFeedbackContent('<span class="error">YAMLデータを入力してください。</span>');
                return;
            }

            setIsLoading(true);
            setFeedbackContent('うフィードバックを生成中...');
            console.debug("うGenerating feedback...");

            // 外部スクリプトの FeedbackGenerator.createFeedbackFromYAML を使用
            const result = FeedbackGenerator.createFeedbackFromYAML(yamlData);
            console.log(result.feedback);
            console.debug("FeedbackGenerator.createFeedbackFromYAML returned:", result);

            if (result.success) {
                // marked.jsを使用してMarkdownをHTMLに変換
                const htmlContent = marked.parse(result.feedback);
                console.debug("Converted Markdown to HTML:", htmlContent);
                setFeedbackContent(htmlContent);
            } else {
                setFeedbackContent(`<span class="error">${result.message}</span>`);
            }

            setIsLoading(false);
        };

        return (
            <div className="feedback-section">
                <h3>プレゼンテーション評価フィードバック生成ツール</h3>
                {/* YAML入力エリアは表示しない */}
                {/* フィードバック生成ボタンは非表示 */}
                {/* 自動生成されたフィードバックを表示 */}
                <div id="feedbackContent" dangerouslySetInnerHTML={{ __html: feedbackContent }}></div>
                {isLoading && console.debug("Feedback is loading...")}
            </div>
        );
    };

    /***********************************************
     *  ツリー（5段階評価のみ）
     ***********************************************/
    const TreeItem = ({ item, currentProgress, setCurrentProgress, forceAllOpen }) => {
        console.debug(`TreeItem rendered for item: ${item.label} (ID: ${item.id})`);
        const [isOpen, setIsOpen] = useState(false);

        useEffect(() => {
            console.debug(`useEffect for TreeItem ID ${item.id} with forceAllOpen: ${forceAllOpen}`);
            if (forceAllOpen) {
                setIsOpen(true);
            }
        }, [forceAllOpen, item.id]);

        // 子要素を平均して、親要素へ反映したい場合など
        useEffect(() => {
            if (item.children && item.children.length > 0) {
                console.debug(`Calculating average progress for parent item: ${item.label}`);
                const childrenCount = item.children.length;
                let total = 0;
                item.children.forEach(child => {
                    const cp = currentProgress[`progress-${child.id}`] || 1;
                    console.debug(`Child ID ${child.id} progress: ${cp}`);
                    total += cp;
                });
                const average = childrenCount > 0 ? parseFloat((total / childrenCount).toFixed(2)) : 0;
                const existingProgress = currentProgress[`progress-${item.id}`] || 1;
                console.debug(`Calculated average: ${average}, Existing progress: ${existingProgress}`);
                // 更新が必要な場合のみセット
                if (Math.abs(average - existingProgress) > 0.001) {
                    console.debug(`Updating progress for parent item ID ${item.id} to average: ${average}`);
                    setCurrentProgress(prev => ({
                        ...prev,
                        [`progress-${item.id}`]: average
                    }));
                }
            }
        }, [item.children, item.id, currentProgress, setCurrentProgress]);

        const toggleOpen = () => {
            console.debug(`Toggle open state for item ID ${item.id}. Current state: ${isOpen}`);
            setIsOpen(!isOpen);
        };

        const handleStepClick = (step) => {
            console.debug(`handleStepClick called for item ID ${item.id} with step: ${step}`);
            // 子要素がある場合はクリックしても何もしない
            if (item.children && item.children.length > 0) {
                console.debug(`Item ID ${item.id} has children. Click ignored.`);
                return;
            }
            setCurrentProgress(prev => ({
                ...prev,
                [`progress-${item.id}`]: step
            }));
            console.debug(`Progress for item ID ${item.id} set to ${step}`);
        };

        const progressValue = currentProgress[`progress-${item.id}`] || 1;
        console.debug(`Current progress value for item ID ${item.id}: ${progressValue}`);

        return (
            <li>
                <div className="tree-item">
                    {item.children && item.children.length > 0 ? (
                        <button
                            className={`toggle-button ${isOpen ? 'expanded' : ''}`}
                            onClick={() => {
                                console.debug(`Toggle button clicked for item ID ${item.id}`);
                                toggleOpen();
                            }}
                            aria-expanded={isOpen}
                            title={isOpen ? '子項目を折りたたむ' : '子項目を展開する'}
                        >
                            {isOpen ? '▼' : '▶'}
                        </button>
                    ) : <span className="toggle-button"></span>}

                    <span className="item-label">{item.label}</span>

                    {/* 親要素の場合 => プロ */}
                    {item.children && item.children.length > 0 ? (
                        <div className="progress-bar-container" title={`進捗: ${progressValue.toFixed(2)}/5`}>
                            <div
                                className="progress-bar"
                                style={{ width: `${scaleProgress(progressValue)}%` }}
                            ></div>
                            <span className="progress-text">{progressValue.toFixed(2)}/5</span>
                        </div>
                    ) : (
                        /* 5段階評価 */
                        <div className="progress-indicator">
                            {[1, 2, 3, 4, 5].map(step => (
                                <span
                                    key={step}
                                    className={`step ${step <= progressValue ? 'active' : ''}`}
                                    onClick={() => {
                                        console.debug(`Step ${step} clicked for item ID ${item.id}`);
                                        handleStepClick(step);
                                    }}
                                    title={`進捗を${step}に設定`}
                                    tabIndex={0}
                                    role="button"
                                    aria-pressed={step <= progressValue}
                                    onKeyPress={(e) => {
                                        if (e.key === 'Enter' || e.key === ' ') {
                                            console.debug(`Key pressed (${e.key}) on step ${step} for item ID ${item.id}`);
                                            handleStepClick(step);
                                        }
                                    }}
                                >
                                    {step}
                                </span>
                            ))}
                        </div>
                    )}
                </div>

                {/* 子要素 */}
                {item.children && item.children.length > 0 && isOpen && (
                    <ul className="tree">
                        {item.children.map(child => (
                            <TreeItem
                                key={child.id}
                                item={child}
                                currentProgress={currentProgress}
                                setCurrentProgress={setCurrentProgress}
                                forceAllOpen={forceAllOpen}
                            />
                        ))}
                    </ul>
                )}
            </li>
        );
    };

    const TreeComponent = ({ data, currentProgress, setCurrentProgress, forceAllOpen }) => {
        console.debug("TreeComponent rendered with data:", data);
        return (
            <ul className="tree">
                {data.map(item => (
                    <TreeItem
                        key={item.id}
                        item={item}
                        currentProgress={currentProgress}
                        setCurrentProgress={setCurrentProgress}
                        forceAllOpen={forceAllOpen}
                    />
                ))}
            </ul>
        );
    };

    /***********************************************
     *  チャート（レーダー）
     ***********************************************/
    const SummaryChartComponent = ({ data, currentProgress }) => {
        console.debug("SummaryChartComponent rendered with data:", data, "and currentProgress:", currentProgress);
        const chartRef = useRef(null);
        const chartInstanceRef = useRef(null);

        useEffect(() => {
            console.debug("SummaryChartComponent useEffect triggered.");
            if (!data || data.length === 0) {
                console.warn("No data available for SummaryChartComponent.");
                return;
            }

            const rootLevelItems = data;
            const labels = rootLevelItems.map(item => item.label);
            console.debug("Radar chart labels:", labels);

            // さらに下の階層がある場合は合計する例
            const getDeepSum = (children) => {
                console.debug("getDeepSum called for children:", children);
                let total = 0;
                children.forEach(child => {
                    const progressVal = currentProgress[`progress-${child.id}`] || 1;
                    console.debug(`Child ID ${child.id} progress: ${progressVal}`);
                    if (child.children && child.children.length > 0) {
                        total += getDeepSum(child.children);
                    } else {
                        total += progressVal;
                    }
                });
                console.debug("Returning total from getDeepSum:", total);
                return total;
            };

            const chartData = rootLevelItems.map(item => {
                if (!item.children || item.children.length === 0) {
                    const p = currentProgress[`progress-${item.id}`] || 1;
                    console.debug(`Item ID ${item.id} has no children. Progress: ${p}`);
                    return p;
                } else {
                    const sum = getDeepSum(item.children);
                    console.debug(`Item ID ${item.id} has children. Sum of progress: ${sum}`);
                    return sum;
                }
            });
            console.debug("Radar chart data:", chartData);

            // 既存チャートを破棄
            if (chartInstanceRef.current) {
                console.debug("Destroying existing radar chart instance.");
                chartInstanceRef.current.destroy();
            }

            const ctx = chartRef.current.getContext('2d');
            console.debug("Creating new radar chart instance.");
            chartInstanceRef.current = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Progress Summary',
                        data: chartData,
                        backgroundColor: 'rgba(34, 202, 236, 0.2)',
                        borderColor: 'rgba(34, 202, 236, 1)',
                        pointBackgroundColor: 'rgba(34, 202, 236, 1)',
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            min: 0,
                            max: 20, // 適宜調整
                            ticks: {
                                stepSize: 1,
                                backdropColor: 'rgba(255,255,255,0)',
                                color: '#666'
                            },
                            angleLines: {
                                color: '#ccc'
                            },
                            grid: {
                                color: '#ccc'
                            },
                            pointLabels: {
                                font: {
                                    size: 14
                                },
                                color: '#333'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: '進捗サマリー',
                            font: {
                                size: 18
                            }
                        }
                    }
                }
            });
            console.debug("Radar chart instance created successfully.");

            return () => {
                if (chartInstanceRef.current) {
                    console.debug("Cleaning up radar chart instance.");
                    chartInstanceRef.current.destroy();
                }
            };
        }, [data, currentProgress]);

        return (
            <div style={{ width: '80%', height: '400px', margin: '0 auto' }}>
                <canvas ref={chartRef}></canvas>
            </div>
        );
    };

    /***********************************************
     *  スナップショット比較コンポーネント
     *   => 選択されたスナップショットを
     *      1つのレーダーチャートにオーバーレイして表示
     ***********************************************/
    const ComparisonComponent = ({ userName }) => {
        console.debug("ComparisonComponent rendered with userName:", userName);
        const [progressHistory, setProgressHistory] = useState([]);
        // チェックボックスで選択されたスナップショットID（timestamp）
        const [selectedSnapshots, setSelectedSnapshots] = useState([]);
        const [comparisonData, setComparisonData] = useState(null);

        const radarChartRef = useRef(null);
        const radarChartInstanceRef = useRef(null);

        useEffect(() => {
            console.debug("ComparisonComponent useEffect for loading progress history.");
            if (userName) {
                const snapshots = JSON.parse(localStorage.getItem(`snapshots_${userName}`)) || [];
                console.debug(`Loaded snapshots for comparison:`, snapshots);
                setProgressHistory(snapshots);
            }
        }, [userName]);

        // 選択スナップショットが変更されたら比較用データを更新
        useEffect(() => {
            console.debug("ComparisonComponent useEffect for selectedSnapshots change.");
            if (selectedSnapshots.length > 0 && userName) {
                console.debug("Selected snapshots for comparison:", selectedSnapshots);
                const snapshots = JSON.parse(localStorage.getItem(`snapshots_${userName}`)) || [];
                const rootLevelItems = window.globalData || [];
                const labels = rootLevelItems.map(item => item.label);
                console.debug("Comparison radar chart labels:", labels);

                // 合計値を取得する再帰関数
                const getDeepSum = (children, snapshotData) => {
                    console.debug("getDeepSum called for comparison with children:", children);
                    let total = 0;
                    children.forEach(child => {
                        const progressVal = snapshotData[`progress-${child.id}`] || 1;
                        console.debug(`Child ID ${child.id} progress in snapshot: ${progressVal}`);
                        if (child.children && child.children.length > 0) {
                            total += getDeepSum(child.children, snapshotData);
                        } else {
                            total += progressVal;
                        }
                    });
                    console.debug("Returning total from getDeepSum for comparison:", total);
                    return total;
                };

                // datasetsを格納する配列
                const datasets = [];

                // 選択された各スナップショットごとにレーダー用データを作成
                selectedSnapshots.forEach((timestamp, index) => {
                    console.debug(`Processing selected snapshot with timestamp: ${timestamp}`);
                    const snapshotRecord = snapshots.find(record => record.timestamp === timestamp);
                    if (!snapshotRecord) {
                        console.warn(`Snapshot with timestamp ${timestamp} not found.`);
                        return; // 念のため
                    }

                    const snapshotData = snapshotRecord.data || {};
                    const dataForChart = rootLevelItems.map(item => {
                        if (!item.children || item.children.length === 0) {
                            const p = snapshotData[`progress-${item.id}`] || 1;
                            console.debug(`Snapshot data for item ID ${item.id}: ${p}`);
                            return p;
                        } else {
                            const sum = getDeepSum(item.children, snapshotData);
                            console.debug(`Snapshot sum for parent item ID ${item.id}: ${sum}`);
                            return sum;
                        }
                    });
                    console.debug(`Data for chart from snapshot ${timestamp}:`, dataForChart);

                    // データセットごとに色を変える例
                    const colorSet = [
                        'rgba(255, 99, 132, 0.6)',
                        'rgba(54, 162, 235, 0.6)',
                        'rgba(255, 206, 86, 0.6)',
                        'rgba(75, 192, 192, 0.6)',
                        'rgba(153, 102, 255, 0.6)',
                        'rgba(255, 159, 64, 0.6)',
                    ];
                    const chartColor = colorSet[index % colorSet.length] || 'rgba(100,100,100,0.6)';
                    console.debug(`Assigning color ${chartColor} to snapshot ${timestamp}`);

                    datasets.push({
                        label: new Date(timestamp).toLocaleString(),
                        data: dataForChart,
                        backgroundColor: chartColor,
                        borderColor: chartColor.replace('0.6', '1'),
                        pointBackgroundColor: chartColor.replace('0.6', '1'),
                        fill: true,
                    });
                });

                setComparisonData({ labels, datasets });
                console.debug("Comparison data set for radar chart:", { labels, datasets });
            } else {
                console.debug("No snapshots selected for comparison. Clearing comparisonData.");
                setComparisonData(null);
            }
        }, [selectedSnapshots, userName]);

        // comparisonData が変わるたびにレーダーチャートを描画
        useEffect(() => {
            console.debug("ComparisonComponent useEffect for comparisonData change.");
            // 既存チャートの破棄
            if (radarChartInstanceRef.current) {
                console.debug("Destroying existing comparison radar chart instance.");
                radarChartInstanceRef.current.destroy();
            }

            if (comparisonData && comparisonData.datasets && comparisonData.datasets.length > 0) {
                console.debug("Creating new comparison radar chart with data:", comparisonData);
                const ctx = radarChartRef.current.getContext('2d');
                radarChartInstanceRef.current = new Chart(ctx, {
                    type: 'radar',
                    data: {
                        labels: comparisonData.labels,
                        datasets: comparisonData.datasets,
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            r: {
                                min: 0,
                                max: 20,
                                beginAtZero: true
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top'
                            },
                            title: {
                                display: true,
                                text: 'スナップショット比較'
                            }
                        }
                    }
                });
                console.debug("Comparison radar chart instance created successfully.");
            }
            return () => {
                if (radarChartInstanceRef.current) {
                    console.debug("Cleaning up comparison radar chart instance.");
                    radarChartInstanceRef.current.destroy();
                }
            };
        }, [comparisonData]);

        // チェックボックスのクリック
        const handleCheckboxChange = (timestamp) => {
            console.debug(`Checkbox changed for snapshot timestamp: ${timestamp}`);
            setSelectedSnapshots(prev => {
                if (prev.includes(timestamp)) {
                    console.debug(`Snapshot ${timestamp} is already selected. Removing it.`);
                    return prev.filter(t => t !== timestamp);
                }
                console.debug(`Snapshot ${timestamp} is not selected. Adding it.`);
                return [...prev, timestamp];
            });
        };

        return (
            <div className="comparison-container" style={{ marginTop: '20px' }}>
                <h3>進捗の比較</h3>
                {progressHistory.length > 0 ? (
                    <div>
                        <p>比較したいスナップショットを選択してください（複数可）:</p>
                        <div className="comparison-list">
                            {progressHistory.map((record) => {
                                const recordTime = new Date(record.timestamp).toLocaleString();
                                return (
                                    <div className="comparison-item" key={record.timestamp}>
                                        <input
                                            type="checkbox"
                                            checked={selectedSnapshots.includes(record.timestamp)}
                                            onChange={() => {
                                                console.debug(`Checkbox toggled for snapshot: ${record.timestamp}`);
                                                handleCheckboxChange(record.timestamp);
                                            }}
                                            id={`snapshot-${record.timestamp}`}
                                        />
                                        <label htmlFor={`snapshot-${record.timestamp}`} style={{ marginLeft: '8px' }}>
                                            {recordTime}
                                        </label>
                                    </div>
                                );
                            })}
                        </div>

                        {/* 比較結果の表示: レーダーチャートのみ */}
                        {(!comparisonData || !comparisonData.datasets || comparisonData.datasets.length === 0) && (
                            <p style={{ color: 'red', marginTop: '10px' }}>
                                スナップショットを一つ以上選択してください。
                            </p>
                        )}
                        {comparisonData && comparisonData.datasets && comparisonData.datasets.length > 0 && (
                            <div style={{ marginTop: '20px' }}>
                                <div className="radar-chart" style={{ marginTop: '20px' }}>
                                    <h4>レーダーチャートによる比較</h4>
                                    <div style={{ width: '80%', height: '400px', margin: '0 auto' }}>
                                        <canvas ref={radarChartRef}></canvas>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                ) : (
                    <p>比較するためのスナップショットがありません。</p>
                )}
            </div>
        )};

    /***********************************************
     *  メインアプリ
     ***********************************************/
    const App = () => {
        console.debug("App component initialized.");
        const [data, setData] = useState([]);
        const [showChart, setShowChart] = useState(false);
        const [showComparison, setShowComparison] = useState(false);
        const [userName, setUserName] = useState('default_user');
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState(null);
        const [snapshots, setSnapshots] = useState([]);
        const [currentProgress, setCurrentProgress] = useState({});
        const [forceAllOpen, setForceAllOpen] = useState(false);

        // Collapsible states
        const [showExportImport, setShowExportImport] = useState(false);
        const [showSnapshotList, setShowSnapshotList] = useState(false);

        // Self-Evaluation
        const [selfEvaluation, setSelfEvaluation] = useState('');

        // exportedYaml state
        const [exportedYaml, setExportedYaml] = useState('');

        // 初回: localStorageからユーザー名と自己評価を読み込み
        useEffect(() => {
            console.debug("App useEffect: Loading initial userName and selfEvaluation from localStorage.");
            const savedUserName = localStorage.getItem('current_user') || 'default_user';
            console.debug(`Saved userName: ${savedUserName}`);
            setUserName(savedUserName);
            const savedEval = localStorage.getItem(`self_evaluation_${savedUserName}`) || '';
            console.debug(`Saved selfEvaluation for ${savedUserName}: ${savedEval}`);
            setSelfEvaluation(savedEval);
        }, []);

        // ユーザー名が変われば自己評価を保存
        useEffect(() => {
            console.debug(`App useEffect: userName changed to ${userName}. Saving selfEvaluation.`);
            if (userName) {
                localStorage.setItem(`self_evaluation_${userName}`, selfEvaluation);
                console.debug(`Self-Evaluation saved for userName ${userName}.`);
            }
        }, [selfEvaluation, userName]);

        // ユーザー名が変わればスナップショットを読み込み
        useEffect(() => {
            console.debug(`App useEffect: Loading snapshots for userName ${userName}.`);
            if (userName) {
                localStorage.setItem('current_user', userName);
                const snapshotsKey = `snapshots_${userName}`;
                const loadedSnapshots = JSON.parse(localStorage.getItem(snapshotsKey)) || [];
                console.debug(`Loaded snapshots for ${userName}:`, loadedSnapshots);
                setSnapshots(loadedSnapshots);
                if (loadedSnapshots.length > 0) {
                    const latestData = loadedSnapshots[loadedSnapshots.length - 1].data;
                    console.debug("Setting currentProgress to latest snapshot data:", latestData);
                    setCurrentProgress(latestData);
                } else {
                    console.debug("No snapshots found. Resetting currentProgress.");
                    setCurrentProgress({});
                }
            }
        }, [userName]);

        // ダミーデータ読み込み（実際はAPI等から取得）
        useEffect(() => {
            console.debug("App useEffect: Loading mock data.");
            const mockData = [
                {
                    "id": 100,
                    "label": "原稿",
                    "children": [
                        { "id": 101, "label": "わかりやすい英語で書かれているか", "children": [] },
                        { "id": 102, "label": "分かりやすい構成で書かれているか", "children": [] },
                        { "id": 103, "label": "要点をまとめて書かれているか", "children": [] },
                        { "id": 104, "label": "客観的なデータに基づいて書かれているか", "children": [] }
                    ]
                },
                {
                    "id": 105,
                    "label": "話し方",
                    "children": [
                        { "id": 106, "label": "抑揚をつける話しているか", "children": [] },
                        { "id": 107, "label": "はっきりと大きな声で話しているか", "children": [] },
                        { "id": 108, "label": "聞き取りやすい速度で話せているか", "children": [] },
                        { "id": 109, "label": "表情を動かして話しているか", "children": [] }
                    ]
                },
                {
                    "id": 110,
                    "label": "準備",
                    "children": [
                        { "id": 111, "label": "原稿を覚えているか", "children": [] },
                        { "id": 112, "label": "班員と協力できているか", "children": [] },
                        { "id": 113, "label": "計画的にできたか", "children": [] },
                        { "id": 114, "label": "質問内容を考えているか", "children": [] }
                    ]
                },
                {
                    "id": 115,
                    "label": "客のひきつけ",
                    "children": [
                        { "id": 116, "label": "ジョークをいれているか", "children": [] },
                        { "id": 117, "label": "レーザーポインター等を使っているか", "children": [] },
                        { "id": 118, "label": "疑問形で話しかけているか", "children": [] },
                        { "id": 119, "label": "観察とコミュニケーションをとれているか", "children": [] } // 修正済み
                    ]
                },
                {
                    "id": 120,
                    "label": "スライド",
                    "children": [
                        { "id": 121, "label": "分かりやすい英語でまとめられているか", "children": [] },
                        { "id": 122, "label": "表、グラフ等を入れているか", "children": [] },
                        { "id": 123, "label": "言いたいことを強調しているか", "children": [] },
                        { "id": 124, "label": "原稿とリンクしているか", "children": [] }
                    ]
                },
                {
                    "id": 125,
                    "label": "立ち振る舞い",
                    "children": [
                        { "id": 126, "label": "前を向いて話しているか", "children": [] },
                        { "id": 127, "label": "ジェスチャーをしながら話しているか", "children": [] },
                        { "id": 128, "label": "自信を持って話しているか", "children": [] },
                        { "id": 129, "label": "待っている人が壁に寄りかかったりしていない", "children": [] }
                    ]
                }
            ];
            setData(mockData);
            window.globalData = mockData; 
            console.debug("Mock data set and window.globalData assigned.");
            setLoading(false);
            console.debug("Loading complete. Setting loading state to false.");
        }, []);

        /***********************************************
         *  postMessageの受信設定を追加
         ***********************************************/
        useEffect(() => {
            console.debug("App useEffect: Setting up postMessage listener.");

            const handleMessage = (event) => {
                // 任意のオリジンに「google」というテキストが含まれていれば許可
                if (event.origin.toLowerCase().includes("google")) {
                    console.debug(`許可されたオリジンからのメッセージを受信しました: ${event.origin}`);
                    // ここでメッセージを処理します
                    console.log('受信したメッセージ:', event.data);
                    // 必要に応じてstateの更新や他の処理を行います
                    // 例:
                    // if (event.data.type === 'updateProgress') {
                    //     setCurrentProgress(event.data.payload);
                    // }
                } else {
                    console.warn(`未許可のオリジンからのメッセージを受信しました: ${event.origin}`);
                }
            };

            window.addEventListener('message', handleMessage, false);
            console.debug("postMessage listener added.");

            // クリーンアップ
            return () => {
                window.removeEventListener('message', handleMessage, false);
                console.debug("postMessage listener removed.");
            };
        }, []);

        /***********************************************
         *  ボタンなどのハンドラ
         ***********************************************/
        // PDF出力
        const handleExportPDF = () => {
            console.debug("handleExportPDF called.");
            // 全て展開してからPDF出力
            setForceAllOpen(true);
            console.debug("All nodes set to open for PDF export.");
            setTimeout(() => {
                const element = document.querySelector('.tree-container');
                console.debug("Selected tree-container for PDF export:", element);
                // 一時的に埋め込みチャート作成用の要素を追加
                const chartElement = document.createElement('div');
                chartElement.style.width = '80%';
                chartElement.style.height = '400px';
                chartElement.style.margin = '0 auto';
                chartElement.innerHTML = '<canvas id="exportChart"></canvas>';
                element.appendChild(chartElement);
                console.debug("Temporary chart element appended for PDF export.");

                // 合計データを算出
                const rootItems = data;
                const labels = rootItems.map(item => item.label);
                console.debug("Radar chart labels:", labels);

                const getDeepSum = (children) => {
                    console.debug("getDeepSum called for export chart with children:", children);
                    let total = 0;
                    children.forEach(child => {
                        const progressVal = currentProgress[`progress-${child.id}`] || 1;
                        console.debug(`Child ID ${child.id} progress: ${progressVal}`);
                        if (child.children && child.children.length > 0) {
                            total += getDeepSum(child.children);
                        } else {
                            total += progressVal;
                        }
                    });
                    console.debug("Returning total from getDeepSum for export chart:", total);
                    return total;
                };

                const chartData = rootItems.map(item => {
                    if (!item.children || item.children.length === 0) {
                        const p = currentProgress[`progress-${item.id}`] || 1;
                        console.debug(`Export chart: Item ID ${item.id} has no children. Progress: ${p}`);
                        return p;
                    } else {
                        const sum = getDeepSum(item.children);
                        console.debug(`Export chart: Item ID ${item.id} has children. Sum of progress: ${sum}`);
                        return sum;
                    }
                });
                console.debug("Export chart data:", chartData);

                const ctx = document.getElementById('exportChart').getContext('2d');
                console.debug("Creating export radar chart.");
                new Chart(ctx, {
                    type: 'radar',
                    data: {
                        labels,
                        datasets: [{
                            label: 'Progress Summary (PDF)',
                            data: chartData,
                            backgroundColor: 'rgba(255, 99, 132, 0.2)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            pointBackgroundColor: 'rgba(255, 99, 132, 1)',
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            r: {
                                min: 0,
                                max: 20,
                                ticks: {
                                    stepSize: 1,
                                    backdropColor: 'rgba(255,255,255,0)',
                                    color: '#666'
                                },
                                angleLines: {
                                    color: '#ccc'
                                },
                                grid: {
                                    color: '#ccc'
                                },
                                pointLabels: {
                                    font: {
                                        size: 14
                                    },
                                    color: '#333'
                                }
                            }
                        }
                    }
                });
                console.debug("Export radar chart created.");

                const opt = {
                    margin: 0.5,
                    filename: 'progress_report.pdf',
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: { scale: 2 },
                    jsPDF: { unit: 'in', format: 'a3', orientation: 'portrait' }
                };
                console.debug("Starting PDF generation with html2pdf.");
                html2pdf().from(element).set(opt).save().then(() => {
                    console.debug("PDF generation completed. Removing temporary chart element.");
                    element.removeChild(chartElement);
                    setForceAllOpen(false);
                    console.debug("All nodes set to closed after PDF export.");
                }).catch((error) => {
                    console.error("Error during PDF generation:", error);
                });
            }, 500);
        };

        // テキストエクスポート
        const handleExportText = () => {
            console.debug("handleExportText called.");
            handleExportYAML(userName || 'default_user', setExportedYaml, true);
        };

        // JSONインポート
        const handleImportJSONFile = (e) => {
            console.debug("handleImportJSONFile called with event:", e);
            const file = e.target.files[0];
            if (file) {
                console.debug("File selected for import:", file);
                handleImportJSON(file, userName || 'default_user', () => {
                    console.debug("Import success callback triggered.");
                    alert('インポートが完了しました。ページをリロードします。');
                    window.location.reload();
                });
            } else {
                console.warn("No file selected for import.");
            }
        };

        // 全て展開・折りたたみ
        const expandAllNodes = () => {
            console.debug("expandAllNodes called.");
            setForceAllOpen(true);
        };
        const collapseAllNodes = () => {
            console.debug("collapseAllNodes called.");
            setForceAllOpen(false);
        };

        // スナップショット保存 => 保存時にチャートを自動表示
        const saveSnapshot = () => {
            console.debug("saveSnapshot called.");
            handleExportYAML(userName || 'default_user', setExportedYaml, false);
            saveSnapshotFunction(currentProgress);
            const snapshotsKey = `snapshots_${userName}`;
            const loadedSnapshots = JSON.parse(localStorage.getItem(snapshotsKey)) || [];
            console.debug("Loaded snapshots after save:", loadedSnapshots);
            setSnapshots(loadedSnapshots);
            alert('スナップショットが保存されました。');
            // チャートを表示・更新
            setShowChart(true);
            console.debug("ShowChart state set to true.");
        };

        // スナップショット復元
        const restoreSnapshotFunction = (idx) => {
            console.debug(`restoreSnapshotFunction called with index: ${idx}`);
            const data = restoreSnapshot(idx);
            if (data) {
                setCurrentProgress(data);
                console.debug("currentProgress updated after restoration:", data);
                alert('スナップショットが復元されました。');
            } else {
                console.warn("No data returned from restoreSnapshot.");
            }
        };

        // スナップショット削除
        const deleteSnapshotFunction = (idx) => {
            console.debug(`deleteSnapshotFunction called with index: ${idx}`);
            if (confirm('このスナップショットを削除しますか？')) {
                deleteSnapshot(idx);
                const snapshotsKey = `snapshots_${userName}`;
                const loadedSnapshots = JSON.parse(localStorage.getItem(snapshotsKey)) || [];
                console.debug(`Loaded snapshots after deletion:`, loadedSnapshots);
                setSnapshots(loadedSnapshots);
                if (loadedSnapshots.length > 0) {
                    const latestData = loadedSnapshots[loadedSnapshots.length - 1].data;
                    console.debug("Setting currentProgress to latest snapshot data after deletion:", latestData);
                    setCurrentProgress(latestData);
                } else {
                    console.debug("No snapshots left after deletion. Resetting currentProgress.");
                    setCurrentProgress({});
                }
                alert('スナップショットが削除されました。');
            } else {
                console.debug("Deletion canceled by user.");
            }
        };

        // Collapsible toggles
        const toggleExportImport = () => {
            console.debug(`toggleExportImport called. Current state: ${showExportImport}`);
            setShowExportImport(!showExportImport);
        };
        const toggleSnapshotList = () => {
            console.debug(`toggleSnapshotList called. Current state: ${showSnapshotList}`);
            setShowSnapshotList(!showSnapshotList);
        };
        const handleComparisonToggle = () => {
            console.debug(`handleComparisonToggle called. Current state: ${showComparison}`);
            setShowComparison(prev => !prev);
        };

        // ロード中やエラー
        if (loading) {
            console.debug("App is loading...");
            return <div className="tree-container">Loading...</div>;
        }
        if (error) {
            console.error("App encountered an error:", error);
            return <div className="tree-container">Error: {error.message}</div>;
        }

        return (
            <div className="tree-container">
                <h2>ツリー構造のリトラクタブルチェックリスト (5段階評価)</h2>

                {/* 上部コントロール */}
                <div style={{ marginBottom: '15px' }}>
                    <label style={{ marginRight: '8px' }}>
                        名前:
                        <input
                            type="text"
                            value={userName}
                            onChange={(e) => {
                                console.debug(`UserName input changed to: ${e.target.value}`);
                                setUserName(e.target.value);
                            }}
                            placeholder="ユーザー名"
                            style={{ marginLeft: '5px' }}
                        />
                    </label>
                    <button onClick={expandAllNodes}>すべて展開</button>
                    <button onClick={collapseAllNodes}>すべて折りたたむ</button>
                    <button onClick={() => {
                        console.debug("Toggle showChart state.");
                        setShowChart(!showChart);
                    }}>
                        {showChart ? 'チャートを非表示' : 'チャートを表示'}
                    </button>
                    <button onClick={handleComparisonToggle}>
                        {showComparison ? '比較を非表示' : '比較を表示'}
                    </button>
                </div>

                {/* 2つの折りたたみセクションを横に並べるためのコンテナ */}
                <div className="collapsible-sections-row">
                    {/* エクスポート / インポート */}
                    <div className="collapsible-section">
                        <div className="collapsible-header" onClick={toggleExportImport}>
                            {showExportImport ? '▼' : '▶'} エクスポート / インポート
                        </div>
                        <div className={`collapsible-content ${showExportImport ? 'show' : ''}`}>
                            <button onClick={handleExportText}>テキストとしてエクスポートする</button>
                            <button onClick={handleExportPDF}>PDFとしてエクスポート</button>
                            <div style={{ marginTop: '10px' }}>
                                <label
                                    htmlFor="import-json"
                                    style={{ cursor: 'pointer', color: 'blue', textDecoration: 'underline' }}
                                >
                                    JSONをインポート
                                </label>
                                <input
                                    type="file"
                                    id="import-json"
                                    accept=".json"
                                    style={{ display: 'none' }}
                                    onChange={handleImportJSONFile}
                                />
                            </div>
                        </div>
                    </div>

                    {/* スナップショット一覧 */}
                    <div className="collapsible-section">
                        <div className="collapsible-header" onClick={toggleSnapshotList}>
                            {showSnapshotList ? '▼' : '▶'} 保存済みスナップショット
                        </div>
                        <div className={`collapsible-content ${showSnapshotList ? 'show' : ''}`}>
                            <SnapshotList
                                snapshots={snapshots}
                                onRestore={restoreSnapshotFunction}
                                onDelete={deleteSnapshotFunction}
                            />
                        </div>
                    </div>
                </div>

                {/* 感想・自己評価エリア */}
                <div style={{ margin: '20px 0', padding: '15px', backgroundColor: '#f5f5f5', borderRadius: '8px' }}>
                    <h3 style={{ marginBottom: '10px' }}>感想・自己評価</h3>
                    <textarea
                        value={selfEvaluation}
                        onChange={(e) => {
                            console.debug("Self-Evaluation textarea changed.");
                            setSelfEvaluation(e.target.value);
                        }}
                        placeholder="感想や自己評価を入力してください..."
                        style={{
                            width: '100%',
                            minHeight: '100px',
                            padding: '10px',
                            borderRadius: '4px',
                            border: '1px solid #ddd',
                            resize: 'vertical'
                        }}
                    />
                </div>

                {/* ツリー本体 (5段階評価) */}
                <TreeComponent
                    data={data}
                    currentProgress={currentProgress}
                    setCurrentProgress={setCurrentProgress}
                    forceAllOpen={forceAllOpen}
                />
                {/* レーダーチャートとフィードバック生成機能 */}
                {showChart && (
                    <div style={{ marginTop: '20px' }}>
                        <SummaryChartComponent data={data} currentProgress={currentProgress} />
                        {/* フィードバック生成機能を表示 */}
                        <FeedbackGeneratorTMP exportedYaml={exportedYaml} />
                    </div>
                )}

                {/* スナップショット比較 (複数のスナップショットを1つのグラフにオーバーレイ) */}
                {showComparison && (
                    <ComparisonComponent userName={userName} />
                )}
                {/* ボタン: スナップショットを保存 => 保存後チャートを自動表示 */}
                <div style={{ marginTop: '20px', textAlign: 'center' }}>
                    <button onClick={saveSnapshot}>スナップショットを保存</button>
                </div>
            </div>
        )};

        ReactDOM.render(<App />, document.getElementById('root'));
        console.debug("App component rendered to #root.");
    </script>
</body>
</html>
